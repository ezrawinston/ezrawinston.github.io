<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/brython@3.11.0/brython.min.js">
    </script>
    <script type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/brython@3.11.0/brython_stdlib.js">
    </script>
    <title>PathWord</title>
</head>
<body onload="brython()">

<script type="text/python">

from browser import document, html, bind
import random

document <= html.H2("PathWord")
document <= html.BR()


def stops(ij,kl):
    i,j=ij
    k,l=kl
    if i == k:
        s,t = min(j,l),max(j,l)
        return {(i,x) for x in range(s,t+1,1)}
    if j == l:
        s,t = min(i,k),max(i,k)
        return {(x,j) for x in range(s,t+1,1)}
    if (i > k and j > l):
        return {(i-x,j-x) for x in range(0,j-l+1,1)}
    if (i > k and j < l):
        return {(i-x,j+x) for x in range(0,i-k+1,1)}
    if (i < k and j < l):
        return {(k-x,l-x) for x in range(0,l-j+1,1)}
    if (k > i and l < j):
        return {(k-x,l+x) for x in range(0,k-i+1,1)}

def argwhere(grid,val):
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == val:
                return i,j

def isin(grid,val):
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == val:
                return True
    return False

idx = lambda i,j: '{}{}'.format(i,j)

gs = 5
wl = 5
words = [w.strip() for w in open('wordle-answers-alphabetical.txt','r')]
word = random.choice(words)
abc = [x for x in "abcdefghijklmnopqrstuvwxyz"]
grid = [list(range(gs)) for _ in range(gs)]
pl = []
for i in range(gs):
    for j in range(gs):
        pl.append((i,j))
uwl = list({w for w in word})
choices = random.sample(range(len(pl)),len(uwl))
choices = {pl[i] for i in choices}
for n,(i,j) in enumerate(choices):
    grid[i][j] = uwl[n]
rest = list(set(abc)-{x for x in word})
rest = random.sample(rest,k=len(rest))
a = 0
for i in range(gs):
    for j in range(gs):
        if (i,j) not in choices:
            grid[i][j] = rest[a]
            a += 1


def step(next_letter):
    global is_first
    global grid
    global current_letter
    global guessed
    global done
    global steps
    k,l = argwhere(grid,next_letter)
    document[idx(k,l)].style.border =  "1.5px solid Black"
    if is_first:
        is_first = False
        current_letter = next_letter
        document['in_text'].text = "choose next letter"
        return
    i,j = argwhere(grid,current_letter)
    document[idx(i,j)].style.border =  "1.5px solid White"
    current_letter = next_letter
    guessed = guessed.union({grid[i][j] for (i,j) in stops((i,j),(k,l))})
    for n,w in enumerate(word):
        if w in guessed:
            document["word_"+str(n)].style.backgroundColor = "LawnGreen"
            document["word_"+str(n)].text = w
    for i in range(gs):
        for j in range(gs):
            if grid[i][j] in guessed:
                if grid[i][j] in word:
                    document[idx(i,j)].style.backgroundColor = "LawnGreen"
                    document[grid[i][j]].style.backgroundColor = "LawnGreen"
                else:
                    document[idx(i,j)].style.backgroundColor = "Red"
                    document[grid[i][j]].style.backgroundColor = "Red"
    steps += 1
    done = "_" not in [document["word_"+str(n)].text for n in range(wl)]
    if done:
        document['input'].clear()
        document['steps'].clear()
        document['input'] <= html.H4("congrats! solved in {} steps".format(steps))
    else:
        document['steps'].text = "steps: {}".format(steps)

def good_path(c,n):
    global grid
    i,j = argwhere(grid,c)
    k,l = argwhere(grid,n)
    if not (i==k or j==l or abs(i-k)==abs(j-l)):
        return False
    if abs(i-k) > 3 or abs(j-l) > 3:
        return False
    return True

def validate(next_letter):
    global current_letter
    global is_first
    if ord(next_letter) not in range(97, 123):
        raise ValueError()
    if (not is_first) and (not good_path(current_letter,next_letter)):
        raise ValueError()

done = False
guessed = set()
i= 1
is_first = True
current_letter = ""

document <= html.DIV(id="alphabet")
for x in abc:
    document['alphabet'] <= (html.SPAN(x,id=x,style="padding: 1px 2px 1px 2px") if isin(grid,x) else html.SPAN(x,style="background-color: Red; padding: 1px 2px 1px 2px",id=x))

for i in range(2):
    document <= html.BR()

document <=  html.TABLE(id="grid")
for i,row in enumerate(grid):
    document['grid'] <= html.TR(html.TD(x,style="padding: 5px 10px 5px 10px;border: 1.5px solid White; margin: 0.5px",id=str(i)+str(j)) for j,x in enumerate(row))

for i in range(1):
    document <= html.BR()

document <= html.DIV(id="word")
for n,w in enumerate(word):
    document['word'] <= html.SPAN("_",id="word_"+str(n),style="padding: 1px 2px 1px 2px;margin:0.5px")

for i in range(1):
    document <= html.BR()

document <= html.DIV(id="input")
document['input'] <= html.SPAN("enter starting letter: ",id='in_text')
document['input'] <= html.INPUT(id="in_box",style="width:10px")
document['input'] <= html.BUTTON("enter",id="in_button")
document['in_box'].focus()
document <= html.DIV("", id='error', style="color:Red")
for i in range(1):
    document <= html.BR()

steps = 0
document <= html.H4("steps: 0",id="steps")

@bind(document["in_button"], "click")
def click(ev):
    document['error'].text = ""
    v = document["in_box"].value
    try:
        document["in_box"].value=""
        validate(v)
        step(v)
        document['in_box'].focus()
    except ValueError:
        document["in_box"].value=""
        document['error'].text = "move up to 3 spaces orthogonally or diagonally. enter lowercase letter."
        document['in_box'].focus()

@bind(document["in_box"], "keyup")
def keyup(ev):
    if ev.key == "Enter":
        click(ev)
        document['in_box'].focus()

for i in range(1):
    document <= html.BR()
document <= html.H4("Goal: ",style="display:inline")
document <= html.SPAN("Deduce the word by reaching the correct letters in the grid. One letter is already ruled out.")
document <= html.BR()
document <= html.BR()
document <= html.H4("Rules: ",style="display:inline")
document <= html.SPAN("Choose a letter to start from. Then choose a letter to move to. You can move up to 3 spaces orthogonally or diagonally, checking all the letters you pass over.")
document <= html.BR()
document <= html.BR()
document <= html.SPAN("Refresh this page to get a new puzzle")
</script>
</body>
</html>